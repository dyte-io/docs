---
sidebar_position: 1
description: >-
  Get an overview of webhooks and their functionality in Dyte's capabilities.
  Follow our guide for a comprehensive understanding.
---

# Webhooks Overview

Webhooks are a powerful way for web applications to communicate with each other in real-time. They enable one application to send automated messages or data to another application when a specific event occurs. This mechanism is widely used for various integrations. Webhooks are efficient because they push updates immediately, eliminating the need for constant polling, and promoting event-driven architectural style.

Setting up a webhook involves the following steps:

1. The client provides a unique URL to the server API and specifies which event
   it wants to be notified about.
2. Once the webhook is configured, the server automatically sends the relevant
   payload to the client's webhook URL when the specified event occurs.

Dyte uses webhooks to notify your application when an event happens. Webhooks
are particularly useful for asynchronous events, such as when a recording is
uploaded or when a participant joins your meeting.

## How does Dyte use Webhooks?

A webhook enables Dyte to push real-time updates to your applications. When the
event occurs, Dyte makes an HTTP request (usually a POST) to the URL you
configured for the webhook and sends the updates to your application as a JSON
payload. You can then use these events to perform actions in your backend
systems. Check out the list of events Dyte supports on [Webhook Events](/guides/capabilities/webhooks/webhook-events) page.

Webhooks are particularly useful for asynchronous events, such as when a
recording is uploaded or when a participant joins the meeting.

Let's say you have a meeting that you want to record. You have registered to
receive the `meeting.started` and `meeting.ended` events. A webhook notifies your
app when the meeting starts and when it ends. After your webhook endpoint
receives the `meeting.started` event, your webhook function can run backend
actions to start recording the meeting and end the recording of the meeting when
`meeting.ended` event is received.

## Anatomy of a Webhook

A webhook HTTP request generally consists of the following:

- Header
- Payload

### Header

For each event that triggers the webhook, a header is included to describe the event. The header provides information about the request, such as content type, webhook ID, UUID, signature details, and so on.

<img
  src="/static/webhook/webhook_id.png"
  width="600"
  height="300"
  alt="webhook-id"
  className="webhook-id-use"
/>

The following headers are of more importance for your security and reliability:

| **Header**        | **Description**                                                                                                                                                                                                                                                                                                                                               |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dyte-webhook-id` | Webhook IDs are used to uniquely identify a specific webhook endpoint or events. See [Verify using webhook IDs](/guides/capabilities/webhooks/signatures#verify-using-webhook-ids).                                                                                                                                                                           |
| `dyte-uuid`       | This is a unique UUID identifying the event.                                                                                                                                                                                                                                                                                                                  |
| `dyte-signature`  | Dyte verifies the webhook events it sends to your endpoints by including a signature in the dyte-signature header of each event. This allows you to confirm that the event came from Dyte and not a malicious server impersonating Dyte. See [Verify Webhooks Using Dyte's Signature](/guides/capabilities/webhooks/signatures#verify-using-dytes-signature). |

### Payload

The payload contains information about the event that triggered the webhook, such as user data or a state change.

For example,

```json
{
  "event": "livestreaming.statusUpdate",
  "streamId": "d231d346-c422-43a6-a324-c0d65b79c8a7",
  "status": "OFFLINE"
}
```

### Developing and Testing Webhooks

Developing and testing webhooks can be time-consuming, especially during the development phase when your webhook API is under construction. You can use [Beeceptor](https://beeceptor.com/webhook-integration/?utm_source=social&utm_campaign=dyte-io), a tool that can significantly fast-track your webhook development by providing features like mock-endpoints and local-tunnels. Here is how:

* **HTTP Mock endpoint**: Using an HTTPS mock endpoint you can simulate the behavior of real webhook consumers. Use this to discover various events and respective payloads.
* **Local tunnel**: Local tunnels provide a secure public HTTPs endpoint that exposes a local web service running on your localhost. This eliminates the complexity of roundtrip deployments when developing webhooks, and enables faster integration.


<head>
  <title>Webhooks Overview Guide</title>
  <meta name="description" content="Get an overview of webhooks and their functionality in Dyte's capabilities. Follow our guide for a comprehensive understanding."/>
</head>
